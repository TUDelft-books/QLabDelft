<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Arduino Serial Plot</title>

  <!-- Chart.js + zoom plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

  <style>
    body { font-family: sans-serif; margin: 20px; }
    canvas { max-width: 100%; height: 450px !important; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom: 10px; }
    .controls label { display:flex; align-items:center; gap:6px; }
    #status { white-space: pre-wrap; background:#f7f7f9; border:1px solid #ddd; padding:8px; border-radius:6px; max-height: 9em; overflow:auto; }
    .muted { color:#666; font-size: 0.9em; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>

<div class="controls">
  <button id="connectButton">Verbinden</button>
  <button id="playPauseButton">Stop</button>
  <button id="resetButton">Reset</button>
  <button id="exportButton">Export CSV</button>
  <button id="saveVisibleCsvButton">Save Visible CSV</button>
  <label>Baudrate:
    <input type="number" id="baudRate" value="9600" min="300" step="100">
  </label>
  <label>Schaalfactor:
    <input type="number" id="scaleFactor" value="1" step="0.001">
  </label>
  <label>Offset:
    <input type="number" id="offsetValue" value="0" step="0.0001">
  </label>
  <label>Puntgrootte:
    <input type="range" id="pointSize" min="0" max="6" step="1" value="2">
  </label>
</div>

<!-- UV-sturing + helderheid -->
<div class="controls">
  <label>UV-duur (s):
    <input type="number" id="uvSeconds" min="1" max="60" value="5">
  </label>
  <button id="uvOnButton">UV aan</button>

  <label>Helderheid (0–255):
    <input type="range" id="uvBrightness" min="0" max="255" step="1" value="150">
    <span id="uvBrightnessVal" class="mono">150</span>
  </label>
  <button id="setBrightnessButton">Instellen</button>

  <span class="muted">Regels met <code>#</code> zijn status (hieronder zichtbaar); overige regels zijn meetdata.</span>
</div>

<canvas id="chartCanvas"></canvas>

<h3>Status</h3>
<div id="status"></div>

<script>
let port, reader, writer;
let keepReading = true;
let dataPoints = [];
let buffer = '';
let baseTimeSec = null;     // t=0 bij verbinden of bij reset op UV_OFF
let encoder = new TextEncoder();

const scaleFactorEl = document.getElementById("scaleFactor");
const offsetEl = document.getElementById("offsetValue");
const pointSizeEl = document.getElementById("pointSize");
const uvSecondsEl = document.getElementById("uvSeconds");
const uvBrightnessEl = document.getElementById("uvBrightness");
const uvBrightnessValEl = document.getElementById("uvBrightnessVal");
const statusBox = document.getElementById("status");

function logStatus(line) {
  const ts = new Date().toLocaleTimeString();
  statusBox.textContent += `[${ts}] ${line}\n`;
  statusBox.scrollTop = statusBox.scrollHeight;
}

const ctx = document.getElementById('chartCanvas').getContext('2d');
const chart = new Chart(ctx, {
  type: 'scatter',
  data: {
    datasets: [{
      label: 'Spanning (V)',
      borderColor: 'rgb(75,192,192)',
      backgroundColor: 'rgb(75,192,192)',
      showLine: false,
      pointRadius: 2,
      data: []
    }]
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    parsing: false, // we geven x,y objecten
    scales: {
      x: {
        type: 'linear',
        min: 0,
        max: 60,

        // ✅ ALTIJD hele seconden
        ticks: {
          stepSize: 1,
          precision: 0,          // geen decimalen
          autoSkip: false        // geen ticks overslaan
        },

        // ✅ Gridlijnen exact op hele seconden
        grid: {
          drawTicks: true,
          drawBorder: true,
          color: (ctx) => {
            // alle verticale gridlijnen even duidelijk
            return '#bbb';
          },
          lineWidth: 0.6
        },

        title: {
          display: true,
          text: "Tijd (s)"
        }
      },
      y: {
        min: 0,
        title: { display:true, text:"Spanning (V)" }
      }
    },
    plugins: {
      zoom: {
        pan: { enabled: true, mode: 'xy' },
        zoom: { wheel:{enabled:true}, pinch:{enabled:true}, mode:'xy' }
      }
    }
  }
});

// Puntgrootte live
pointSizeEl.addEventListener("input", () => {
  const r = Number(pointSizeEl.value);
  chart.data.datasets[0].pointRadius = r;
  chart.update("none");
});

async function connectSerial() {
  const baudRate = parseInt(document.getElementById('baudRate').value);
  try {
    port = await navigator.serial.requestPort();
    await port.open({ baudRate });

    // Writer voor commando's
    writer = port.writable.getWriter();

    await startReading(true); // meteen lezen, t=0 vanaf nu
    document.getElementById('playPauseButton').textContent = 'Stop';
    logStatus('Verbonden');
  } catch (err) {
    console.error(err);
    logStatus('Fout bij verbinden: ' + err.message);
  }
}
document.getElementById("connectButton").addEventListener("click", connectSerial);

async function startReading(freshTime = false) {
  if (!port || !port.readable) return;
  try {
    if (reader) { await reader.cancel(); reader.releaseLock(); }
  } catch (_) { /* negeren */ }
  reader = port.readable.getReader();

  if (freshTime) {
    baseTimeSec = Date.now() / 1000;   // t=0 nu
    dataPoints = [];
    chart.data.datasets[0].data = [];
    chart.options.scales.x.min = 0;
    chart.options.scales.x.max = 60;
    chart.options.scales.y.min = 0;
    delete chart.options.scales.y.max;
    chart.update();
  }

  keepReading = true;
  readLoop();
}

async function readLoop() {
  const decoder = new TextDecoder();
  while (keepReading) {
    try {
      const { value, done } = await reader.read();
      if (done) break;
      if (value) {
        buffer += decoder.decode(value, {stream:true});
        let lines = buffer.split("\n");
        buffer = lines.pop();
        for (let line of lines) {
          line = line.replace(/\r/g,'').trim();
          if (!line) continue;

          // Statuslijn?
          if (line.startsWith('#')) {
            logStatus(line);

            // NIEUW: resetten zodra UV uitgaat
            if (line.startsWith('#UV_OFF')) {
              resetPlotInPlace();   // zie functie onderaan
            }
            continue;
          }

          // Datapunt
          const raw = parseFloat(line);
          if (isNaN(raw)) {
            logStatus('Onbekende lijn: ' + line);
            continue;
          }
          const scale = parseFloat(scaleFactorEl.value);
          const offset = parseFloat(offsetEl.value);
          const voltage = raw * scale + offset;

          const tNow = Date.now() / 1000;
          const tRel = tNow - baseTimeSec; // seconden sinds connect of laatst reset

          dataPoints.push({ x: tRel, y: voltage });

          // Alleen laatste 60 s tonen
          const minX = Math.max(0, tRel - 60);
          while (dataPoints.length && dataPoints[0].x < minX) dataPoints.shift();

          chart.data.datasets[0].data = dataPoints;

          // y-as autoscale op zichtbare punten
          const vis = dataPoints;
          if (vis.length) {
            let maxY = Math.max(...vis.map(p => p.y));

            // ✅ y-as begint ALTIJD bij 0 V
            chart.options.scales.y.min = 0;

            // ✅ alleen bovenkant autoscalen
            chart.options.scales.y.max = maxY + Math.max(0.01, maxY * 0.1);
          }
          chart.options.scales.x.min = minX;
          chart.options.scales.x.max = tRel;

          chart.update('none');
        }
      }
    } catch (err) {
      console.error(err);
      logStatus('Leesfout: ' + err.message);
      break;
    }
  }
}

document.getElementById("playPauseButton").addEventListener("click", async () => {
  const btn = document.getElementById("playPauseButton");
  if (keepReading) {
    keepReading = false;
    try { if (reader) { await reader.cancel(); reader.releaseLock(); } } catch (_) {}
    btn.textContent = "Start";
  } else {
    await startReading(false);
    btn.textContent = "Stop";
  }
});

document.getElementById("resetButton").addEventListener("click", async () => {
  // Stop evt. de huidige reader
  keepReading = false;
  try { if (reader) { await reader.cancel(); reader.releaseLock(); } } catch (_) {}

  // Scherm leeg + assen reset
  dataPoints = [];
  chart.data.datasets[0].data = [];
  chart.options.scales.x.min = 0;
  chart.options.scales.x.max = 60;
  chart.options.scales.y.min = 0;
  delete chart.options.scales.y.max;
  chart.update();

  // Als er een open poort is: opnieuw lezen vanaf t=0
  if (port && port.readable) {
    await startReading(true);
    document.getElementById('playPauseButton').textContent = 'Stop';
  }
});

// Export: ALLE data (puntkomma CSV)
document.getElementById('exportButton').addEventListener('click', () => {
  let csv = "data:text/csv;charset=utf-8,";
  csv += "tijd_s;spanning_V\n";
  csv += dataPoints.map(p => `${p.x.toFixed(3)};${p.y}`).join("\n");
  const link = document.createElement("a");
  link.href = encodeURI(csv);
  link.download = "data.csv";
  link.click();
});

// Export: zichtbare data
document.getElementById('saveVisibleCsvButton').addEventListener('click', () => {
  const xMin = chart.options.scales.x.min;
  const xMax = chart.options.scales.x.max;
  const visible = dataPoints.filter(p => p.x >= xMin && p.x <= xMax);
  let csv = "data:text/csv;charset=utf-8,";
  csv += "tijd_s;spanning_V\n";
  csv += visible.map(p => `${p.x.toFixed(3)};${p.y}`).join("\n");
  const link = document.createElement("a");
  link.href = encodeURI(csv);
  link.download = "visible_data.csv";
  link.click();
});

// ===== UV-commando's =====

// Toon numerieke waarde naast slider
uvBrightnessEl.addEventListener('input', () => {
  uvBrightnessValEl.textContent = String(uvBrightnessEl.value);
});

// Knop: Instellen (stuurt BR:<waarde>)
document.getElementById('setBrightnessButton').addEventListener('click', async () => {
  await sendCommandBR();
});

// Optioneel: stuur ook wanneer de slider wordt losgelaten
uvBrightnessEl.addEventListener('change', async () => {
  await sendCommandBR();
});

// Knop: UV aan (stuurt UV:<sec>)
document.getElementById('uvOnButton').addEventListener('click', async () => {
  if (!port || !writer) { logStatus('Niet verbonden'); return; }
  let sec = Math.max(1, Math.min(60, Number(uvSecondsEl.value || 0)));
  uvSecondsEl.value = sec; // clamp zichtbaar
  try {
    await writer.write(encoder.encode(`UV:${sec}\n`));
    logStatus(`Commando verstuurd: UV:${sec}`);
  } catch (err) {
    console.error(err);
    logStatus('Schrijffout: ' + err.message);
  }
});

async function sendCommandBR() {
  if (!port || !writer) { logStatus('Niet verbonden'); return; }
  const val = Math.max(0, Math.min(255, Number(uvBrightnessEl.value || 0)));
  uvBrightnessEl.value = val;
  uvBrightnessValEl.textContent = String(val);
  try {
    await writer.write(encoder.encode(`BR:${val}\n`));
    logStatus(`Commando verstuurd: BR:${val}`);
  } catch (err) {
    console.error(err);
    logStatus('Schrijffout: ' + err.message);
  }
}

// In-place plot resetten zonder de reader te stoppen (gebruikt bij #UV_OFF)
function resetPlotInPlace() {
  baseTimeSec = Date.now() / 1000; // nieuwe t=0
  dataPoints = [];
  chart.data.datasets[0].data = [];
  chart.options.scales.x.min = 0;
  chart.options.scales.x.max = 60;
  chart.options.scales.y.min = 0;
  delete chart.options.scales.y.max;
  chart.update();
}
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Arduino Serial Plot</title>

  <!-- Chart.js + zoom plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

  <style>
    body { font-family: sans-serif; margin: 20px; }
    canvas { max-width: 100%; height: 450px !important; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom: 10px; }
    .controls label { display:flex; align-items:center; gap:6px; }
    #status { white-space: pre-wrap; background:#f7f7f9; border:1px solid #ddd; padding:8px; border-radius:6px; max-height: 9em; overflow:auto; }
    .muted { color:#666; font-size: 0.9em; }
  </style>
</head>
<body>

<div class="controls">
  <button id="connectButton">Verbinden</button>
  <button id="playPauseButton">Stop</button>
  <button id="resetButton">Reset</button>
  <button id="exportButton">Export CSV</button>
  <button id="saveVisibleCsvButton">Save Visible CSV</button>
  <label>Baudrate:
    <input type="number" id="baudRate" value="9600" min="300" step="100">
  </label>
  <label>Schaalfactor:
    <input type="number" id="scaleFactor" value="1" step="0.001">
  </label>
  <label>Offset:
    <input type="number" id="offsetValue" value="0" step="0.0001">
  </label>
  <label>Puntgrootte:
    <input type="range" id="pointSize" min="0" max="6" step="1" value="2">
  </label>
</div>

<!-- Nieuw: UV-sturing -->
<div class="controls">
  <label>UV-duur (s):
    <input type="number" id="uvSeconds" min="1" max="60" value="5">
  </label>
  <button id="uvOnButton">UV aan</button>
  <span class="muted">Statuslijnen met <code>#</code> worden hieronder getoond; overige regels zijn datapunten.</span>
</div>

<canvas id="chartCanvas"></canvas>

<h3>Status</h3>
<div id="status"></div>

<script>
let port, reader, writer;
let keepReading = true;
let dataPoints = [];
let buffer = '';
let baseTimeSec = null;       // <-- nieuw: t=0 bij verbinden
let encoder = new TextEncoder();

const scaleFactorEl = document.getElementById("scaleFactor");
const offsetEl = document.getElementById("offsetValue");
const pointSizeEl = document.getElementById("pointSize");
const uvSecondsEl = document.getElementById("uvSeconds");
const statusBox = document.getElementById("status");

function logStatus(line) {
  const ts = new Date().toLocaleTimeString();
  statusBox.textContent += `[${ts}] ${line}\n`;
  statusBox.scrollTop = statusBox.scrollHeight;
}

const ctx = document.getElementById('chartCanvas').getContext('2d');
const chart = new Chart(ctx, {
  type: 'scatter',
  data: {
    datasets: [{
      label: 'Spanning (V)',
      borderColor: 'rgb(75,192,192)',
      backgroundColor: 'rgb(75,192,192)',
      showLine: false,
      pointRadius: 2,
      data: []
    }]
  },
  options: {
    responsive: true,
    maintainAspectRatio: false,
    parsing: false, // we geven x,y objecten
    scales: {
      x: {
        type: 'linear',
        min: 0,
        max: 60,
        // 0,2 s grid; labels alleen op hele seconden om clutter te voorkomen
        ticks: {
          stepSize: 0.2,
          callback: (value) => (Math.abs(value % 1) < 1e-6 ? value.toFixed(0) : '') // alleen 1s-labels
        },
        grid: { color: "#ccc", lineWidth: 0.3 },
        title: { display:true, text:"Tijd (s)" }
      },
      y: {
        min: 0,
        title: { display:true, text:"Spanning (V)" }
      }
    },
    plugins: {
      zoom: {
        pan: { enabled: true, mode: 'xy' },
        zoom: { wheel:{enabled:true}, pinch:{enabled:true}, mode:'xy' }
      }
    }
  }
});

// Puntgrootte live
pointSizeEl.addEventListener("input", () => {
  const r = Number(pointSizeEl.value);
  chart.data.datasets[0].pointRadius = r;
  chart.update("none");
});

async function connectSerial() {
  const baudRate = parseInt(document.getElementById('baudRate').value);
  try {
    port = await navigator.serial.requestPort();
    await port.open({ baudRate });

    // Writer voor commando's
    writer = port.writable.getWriter();

    await startReading(true); // meteen lezen, t=0 vanaf nu
    document.getElementById('playPauseButton').textContent = 'Stop';
    logStatus('Verbonden');
  } catch (err) {
    console.error(err);
    logStatus('Fout bij verbinden: ' + err.message);
  }
}

document.getElementById("connectButton").addEventListener("click", connectSerial);

async function startReading(freshTime = false) {
  if (!port || !port.readable) return;
  try {
    if (reader) { await reader.cancel(); reader.releaseLock(); }
  } catch (_) { /* negeren */ }
  reader = port.readable.getReader();

  if (freshTime) {
    baseTimeSec = Date.now() / 1000;   // <-- nieuw: t=0 nu
    dataPoints = [];
    chart.data.datasets[0].data = [];
    chart.options.scales.x.min = 0;
    chart.options.scales.x.max = 60;
    delete chart.options.scales.y.max;
    chart.update();
  }

  keepReading = true;
  readLoop();
}

async function readLoop() {
  const decoder = new TextDecoder();
  while (keepReading) {
    try {
      const { value, done } = await reader.read();
      if (done) break;
      if (value) {
        buffer += decoder.decode(value, {stream:true});
        let lines = buffer.split("\n");
        buffer = lines.pop();
        for (let line of lines) {
          line = line.replace(/\r/g,'').trim();
          if (!line) continue;

          // Statusregel?
          if (line.startsWith('#')) {
            logStatus(line);
            continue;
          }

          // Datapunt
          const raw = parseFloat(line);
          if (isNaN(raw)) {
            logStatus('Onbekende lijn: ' + line);
            continue;
          }
          const scale = parseFloat(scaleFactorEl.value);
          const offset = parseFloat(offsetEl.value);
          const voltage = raw * scale + offset;

          const tNow = Date.now() / 1000;
          const tRel = tNow - baseTimeSec; // seconden sinds connect

          dataPoints.push({ x: tRel, y: voltage });

          // Alleen laatste 60 s tonen
          const minX = Math.max(0, tRel - 60);
          // trim buffer (oude punten verwijderen)
          while (dataPoints.length && dataPoints[0].x < minX) dataPoints.shift();

          chart.data.datasets[0].data = dataPoints;
          // y-as autoscale op zichtbare punten
          const vis = dataPoints; // al getrimd
          if (vis.length) {
            let maxY = Math.max(...vis.map(p => p.y));
            let minY = Math.min(...vis.map(p => p.y));
            if (minY === maxY) { minY -= 0.5; maxY += 0.5; }
            chart.options.scales.y.min = minY;
            chart.options.scales.y.max = maxY + Math.max(0.0001, (maxY - minY) * 0.1);
          }
          chart.options.scales.x.min = minX;
          chart.options.scales.x.max = tRel;

          chart.update('none');
        }
      }
    } catch (err) {
      console.error(err);
      logStatus('Leesfout: ' + err.message);
      break;
    }
  }
}

document.getElementById("playPauseButton").addEventListener("click", async () => {
  const btn = document.getElementById("playPauseButton");
  if (keepReading) {
    // STOP lezen
    keepReading = false;
    try {
      if (reader) { await reader.cancel(); reader.releaseLock(); }
    } catch (_) { /* negeren */ }
    btn.textContent = "Start";
  } else {
    // START (verder in tijd)
    await startReading(false);
    btn.textContent = "Stop";
  }
});

document.getElementById("resetButton").addEventListener("click", async () => {
  // Stop evt. de huidige reader
  keepReading = false;
  try {
    if (reader) { await reader.cancel(); reader.releaseLock(); }
  } catch (_) { /* negeren */ }

  // Scherm leeg + assen reset
  dataPoints = [];
  chart.data.datasets[0].data = [];
  chart.options.scales.x.min = 0;
  chart.options.scales.x.max = 60;
  chart.options.scales.y.min = 0;
  delete chart.options.scales.y.max;
  chart.update();

  // Als er een open poort is: direct weer gaan lezen vanaf t=0
  if (port && port.readable) {
    await startReading(true);
    document.getElementById('playPauseButton').textContent = 'Stop';
  }
});

// Export: ALLE data (puntkomma CSV)
document.getElementById('exportButton').addEventListener('click', () => {
  let csv = "data:text/csv;charset=utf-8,";
  csv += "tijd_s;spanning_V\n";
  csv += dataPoints.map(p => `${p.x.toFixed(3)};${p.y}`).join("\n");
  const link = document.createElement("a");
  link.href = encodeURI(csv);
  link.download = "data.csv";
  link.click();
});

// Export: zichtbare data
document.getElementById('saveVisibleCsvButton').addEventListener('click', () => {
  const xMin = chart.options.scales.x.min;
  const xMax = chart.options.scales.x.max;
  const visible = dataPoints.filter(p => p.x >= xMin && p.x <= xMax);
  let csv = "data:text/csv;charset=utf-8,";
  csv += "tijd_s;spanning_V\n";
  csv += visible.map(p => `${p.x.toFixed(3)};${p.y}`).join("\n");
  const link = document.createElement("a");
  link.href = encodeURI(csv);
  link.download = "visible_data.csv";
  link.click();
});

// === Nieuw: UV-commando versturen ===
document.getElementById('uvOnButton').addEventListener('click', async () => {
  if (!port || !writer) { logStatus('Niet verbonden'); return; }
  let sec = Math.max(1, Math.min(60, Number(uvSecondsEl.value || 0)));
  uvSecondsEl.value = sec; // clamp zichtbaar
  try {
    await writer.write(encoder.encode(`UV:${sec}\n`));
    logStatus(`Commando verstuurd: UV:${sec}`);
  } catch (err) {
    console.error(err);
    logStatus('Schrijffout: ' + err.message);
  }
});
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Arduino Serial Plot</title>

  <!-- Chart.js + zoom plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

  <!-- MathJax (LaTeX) -->
  <script>
    window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    body { font-family: sans-serif; margin: 20px; }
    canvas { max-width: 100%; height: 450px !important; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom: 10px; }
    .controls label { display:flex; align-items:center; gap:6px; }
    #status { white-space: pre-wrap; background:#f7f7f9; border:1px solid #ddd; padding:8px; border-radius:6px; max-height: 9em; overflow:auto; }
    .muted { color:#666; font-size: 0.9em; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }

    /* Ingedrukte toggle-knoppen */
    .btn-on { background:#e8f0fe; border:1px solid #3b82f6; }

    /* Speciaal kleurtje voor ingedrukte power-knop */
    .power-btn.btn-on { background:#ffe4e6; border:1px solid #dc2626; color:#7f1d1d; }

    /* Handmatige halfwaardeknop (paarse hint) */
    .manual-on { background:#efe7ff; border:1px solid #7b2cbf; }

    /* Handmatige sliders */
    #manualHalfLifeControls input[type="range"] { width: 160px; }
    #manualHalfLifeControls label { gap: 6px; }
  </style>
</head>
<body>
  <!-- Basis bediening -->
  <div class="controls">
    <button id="connectButton">Verbinden</button>
    <button id="playPauseButton">Stop</button>
    <button id="resetButton">Reset</button>
    <button id="exportButton">Export CSV</button>
    <button id="saveVisibleCsvButton">Save Visible CSV</button>

    <label>Baudrate:
      <input type="number" id="baudRate" value="9600" min="300" step="100">
    </label>
     
    <label>Puntgrootte:
      <input type="range" id="pointSize" min="0" max="6" step="1" value="2">
    </label>
  </div>

  <!-- UV-sturing + helderheid -->
  <div class="controls">
    <label>UV-duur (s):
      <input type="number" id="uvSeconds" min="1" max="60" value="5">
    </label>
    <button id="uvOnButton">UV aan</button>
    <label>Helderheid (0–255):
      <input type="range" id="uvBrightness" min="0" max="255" step="1" value="150">
      <span id="uvBrightnessVal" class="mono">150</span>
    </label>
    <button id="setBrightnessButton">Instellen</button>
    <span class="muted">Regels met <code>#</code> zijn status; overige regels zijn meetdata.</span>
  </div>

  <!-- Verband: halfwaardetijd -->
  <div class="controls">
    <button id="fitHalfLifeButton">Halfwaardetijd-fit</button>
    <span class="muted">
      $I(t)=I_0\cdot\left(\tfrac12\right)^{t/t_{1/2}}$
    </span>
    <span id="halfLifeResult" class="muted"></span>
  </div>

  <!-- Handmatige halfwaardecurve (sliders) -->
  <div class="controls" id="manualHalfLifeControls">
    <button id="toggleManualHalfLife">Handmatige halfwaardecurve</button>
    <span class="muted">
      $I(t)=I_0\cdot\left(\tfrac12\right)^{t/t_{1/2}}$
    </span>

    <label style="margin-left:12px;">$I₀$:
      <input type="range" id="manualI0" min="0.01" max="5" step="0.01" value="1.00">
      <input type="number" id="manualI0Num" min="0.01" max="5" step="0.01" value="1.00" style="width:6em;">
    </label>

    <label>$t_{1/2} (s)$:
      <input type="range" id="manualTH" min="0.05" max="30" step="0.01" value="5.00">
      <input type="number" id="manualTHNum" min="0.05" max="30" step="0.01" value="5.00" style="width:6em;">
    </label>
  </div>

  <!-- Verband: machtswet -->
  <div class="controls">
    <button id="fitPowerButton" class="power-btn">Machtswet-fit</button>
    <span class="muted">
      $I(t)=\dfrac{a}{(t+t_0)^b}$
    </span>
    <span id="fitResult" class="muted"></span>
  </div>

  <canvas id="chartCanvas"></canvas>

  <h3>Status</h3>
  <div id="status"></div>

  <script>
    /* ======= Globale state ======= */
    let port, reader, writer;
    let keepReading = true;
    let dataPoints = [];
    let buffer = '';
    let baseTimeSec = null; // t=0 bij verbinden/reset
    const encoder = new TextEncoder();
    let fitHalfLifeActive = false;
    let fitPowerActive = false;
    let halfLifeDataset = null;
    let powerDataset = null;

    // Handmatige halfwaardecurve state
    let manualHalfLifeActive = false;
    let manualHalfLifeDataset = null;
    
    const pointSizeEl = document.getElementById("pointSize");
    const uvSecondsEl = document.getElementById("uvSeconds");
    const uvBrightnessEl= document.getElementById("uvBrightness");
    const uvBrightnessValEl = document.getElementById("uvBrightnessVal");
    const fitHalfLifeBtn= document.getElementById("fitHalfLifeButton");
    const fitPowerBtn = document.getElementById("fitPowerButton");
    const halfLifeResultEl = document.getElementById("halfLifeResult");
    const fitResultEl = document.getElementById("fitResult");
    const statusBox = document.getElementById("status");

    // Handmatige UI elements
    const toggleManualHalfLifeBtn = document.getElementById("toggleManualHalfLife");
    const manualI0Range   = document.getElementById("manualI0");
    const manualI0Num     = document.getElementById("manualI0Num");
    const manualTHRange   = document.getElementById("manualTH");
    const manualTHNum     = document.getElementById("manualTHNum");

    /* ======= Log ======= */
    function logStatus(line) {
      const ts = new Date().toLocaleTimeString();
      statusBox.textContent += `[${ts}] ${line}\n`;
      statusBox.scrollTop = statusBox.scrollHeight;
    }

    /* ======= Chart ======= */
    const ctx = document.getElementById('chartCanvas').getContext('2d');
    const chart = new Chart(ctx, {
      type: 'scatter',
      data: {
        datasets: [{
          label: 'Spanning (V)',
          borderColor: 'rgb(75,192,192)',
          backgroundColor: 'rgb(75,192,192)',
          showLine: false,
          pointRadius: Number(pointSizeEl.value),
          data: []
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        parsing: false,
        scales: {
          x: {
            type: 'linear',
            min: 0,
            max: 60,
            ticks: { stepSize: 1, precision: 0, autoSkip: false },
            grid: { drawTicks:true, drawBorder:true, color:'#bbb', lineWidth:0.6 },
            title: { display:true, text:"Tijd (s)" }
          },
          y: {
            min: 0,
            title: { display:true, text:"Spanning (V)" }
          }
        },
        plugins: {
          zoom: {
            pan: { enabled: true, mode: 'xy' },
            zoom:{ wheel:{enabled:true}, pinch:{enabled:true}, mode:'xy' }
          }
        }
      }
    });

    function rebuildDatasets() {
      const base = {
        label: 'Spanning (V)',
        borderColor: 'rgb(75,192,192)',
        backgroundColor: 'rgb(75,192,192)',
        showLine: false,
        pointRadius: Number(pointSizeEl.value),
        data: dataPoints
      };
      const list = [base];

      if (fitHalfLifeActive && halfLifeDataset) list.push(halfLifeDataset);
      if (fitPowerActive && powerDataset) list.push(powerDataset);
      if (manualHalfLifeActive && manualHalfLifeDataset) list.push(manualHalfLifeDataset);

      chart.data.datasets = list;
      chart.update('none');
    }

    /* ======= UI ======= */
    pointSizeEl.addEventListener("input", () => rebuildDatasets());

    /* Verbinden */
    document.getElementById("connectButton").addEventListener("click", async () => {
      const baudRate = parseInt(document.getElementById('baudRate').value);
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate });
        writer = port.writable.getWriter();
        await startReading(true); // t=0 nu, alles leeg
        document.getElementById('playPauseButton').textContent = 'Stop';
        logStatus('Verbonden');
      } catch (err) {
        console.error(err);
        logStatus('Fout bij verbinden: ' + err.message);
      }
    });

    async function startReading(freshTime=false) {
      if (!port || !port.readable) return;
      try { if (reader) { await reader.cancel(); reader.releaseLock(); } } catch(_) {}
      reader = port.readable.getReader();

      if (freshTime) {
        baseTimeSec = Date.now()/1000;
        dataPoints = [];
        buffer = '';
        // overlays + UI schoon
        fitHalfLifeActive=false; fitPowerActive=false; manualHalfLifeActive=false;
        halfLifeDataset=null; powerDataset=null; manualHalfLifeDataset=null;
        fitHalfLifeBtn.classList.remove('btn-on'); fitHalfLifeBtn.textContent='Halfwaardetijd-fit';
        fitPowerBtn.classList.remove('btn-on');    fitPowerBtn.textContent ='Machtswet-fit';
        toggleManualHalfLifeBtn.classList.remove('manual-on');
        halfLifeResultEl.textContent=''; fitResultEl.textContent='';
        // assen
        chart.options.scales.x.min = 0;
        chart.options.scales.x.max = 60;
        chart.options.scales.y.min = 0;
        delete chart.options.scales.y.max;
        rebuildDatasets();
      }
      keepReading = true;
      readLoop();
    }

    async function readLoop() {
      const decoder = new TextDecoder();
      while (keepReading) {
        try {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            buffer += decoder.decode(value, {stream:true});
            let lines = buffer.split("\n");
            buffer = lines.pop();
            for (let line of lines) {
              line = line.replace(/\r/g,'').trim();
              if (!line) continue;
              // status
              if (line.startsWith('#')) {
                logStatus(line);
                if (line.startsWith('#UV_OFF')) {
                  resetPlotAfterUV();
                }
                continue;
              }
              // datapunt
              const v = parseFloat(line);
              if (isNaN(v)) { logStatus('Onbekende lijn: ' + line); continue; }
              const voltage = v;
              const tRel = Date.now()/1000 - baseTimeSec;
              dataPoints.push({ x:tRel, y:voltage });
              // 60 s venster
              const minX = Math.max(0, tRel - 60);
              while (dataPoints.length && dataPoints[0].x < minX) dataPoints.shift();
              // y-as
              if (dataPoints.length) {
                const maxY = Math.max(...dataPoints.map(p=>p.y));
                chart.options.scales.y.min = 0;
                chart.options.scales.y.max = maxY + Math.max(0.01, maxY*0.1);
              }
              chart.options.scales.x.min = minX;
              chart.options.scales.x.max = tRel;

              // Als handmatige curve aan staat, updaten zodat schaal meebeweegt
              if (manualHalfLifeActive) updateManualCurve();

              rebuildDatasets();
            }
          }
        } catch (err) {
          console.error(err);
          logStatus('Leesfout: ' + err.message);
          break;
        }
      }
    }

    /* Start/Stop */
    document.getElementById("playPauseButton").addEventListener("click", async () => {
      const btn = document.getElementById("playPauseButton");
      if (keepReading) {
        keepReading = false; try { if (reader) { await reader.cancel(); reader.releaseLock(); } } catch(_) {}
        btn.textContent = "Start";
      } else {
        await startReading(false);
        btn.textContent = "Stop";
      }
    });

    /* RESET: écht opnieuw (alles weg) */
    document.getElementById("resetButton").addEventListener("click", async () => {
      keepReading = false; try { if (reader) { await reader.cancel(); reader.releaseLock(); } } catch(_) {}
      baseTimeSec = Date.now()/1000;
      dataPoints = [];
      buffer = '';
      // overlays + UI uit
      fitHalfLifeActive=false; fitPowerActive=false; manualHalfLifeActive=false;
      halfLifeDataset=null; powerDataset=null; manualHalfLifeDataset=null;
      fitHalfLifeBtn.classList.remove('btn-on'); fitHalfLifeBtn.textContent='Halfwaardetijd-fit';
      fitPowerBtn.classList.remove('btn-on');    fitPowerBtn.textContent ='Machtswet-fit';
      toggleManualHalfLifeBtn.classList.remove('manual-on');
      halfLifeResultEl.textContent=''; fitResultEl.textContent='';
      // assen
      chart.options.scales.x.min = 0;
      chart.options.scales.x.max = 60;
      chart.options.scales.y.min = 0;
      delete chart.options.scales.y.max;
      rebuildDatasets();
      // status ook leegmaken voor "from scratch"
      statusBox.textContent = '';
      if (port && port.readable) {
        await startReading(true);
        document.getElementById('playPauseButton').textContent = 'Stop';
      }
    });

    /* Export */
    document.getElementById('exportButton').addEventListener('click', () => {
      let csv = "data:text/csv;charset=utf-8,";
      csv += "tijd_s;spanning_V\n";
      csv += dataPoints.map(p => `${p.x.toFixed(3)};${p.y}`).join("\n");
      const a = document.createElement("a");
      a.href = encodeURI(csv);
      a.download = "data.csv";
      a.click();
    });
    document.getElementById('saveVisibleCsvButton').addEventListener('click', () => {
      const xMin = chart.options.scales.x.min;
      const xMax = chart.options.scales.x.max;
      const vis = dataPoints.filter(p => p.x >= xMin && p.x <= xMax);
      let csv = "data:text/csv;charset=utf-8,";
      csv += "tijd_s;spanning_V\n";
      csv += vis.map(p => `${p.x.toFixed(3)};${p.y}`).join("\n");
      const a = document.createElement("a");
      a.href = encodeURI(csv);
      a.download = "visible_data.csv";
      a.click();
    });

    /* UV-commando's */
    uvBrightnessEl.addEventListener('input', () => { uvBrightnessValEl.textContent = String(uvBrightnessEl.value); });
    document.getElementById('setBrightnessButton').addEventListener('click', async () => { await sendBR(); });
    uvBrightnessEl.addEventListener('change', async () => { await sendBR(); });

    document.getElementById('uvOnButton').addEventListener('click', async () => {
      if (!port || !writer) { logStatus('Niet verbonden'); return; }
      let sec = Math.max(1, Math.min(60, Number(uvSecondsEl.value || 0)));
      uvSecondsEl.value = sec;
      try {
        await writer.write(encoder.encode(`UV:${sec}\n`));
        logStatus(`Commando verstuurd: UV:${sec}`);
      }
      catch (err) { console.error(err); logStatus('Schrijffout: ' + err.message); }
    });

    async function sendBR() {
      if (!port || !writer) { logStatus('Niet verbonden'); return; }
      const val = Math.max(0, Math.min(255, Number(uvBrightnessEl.value || 0)));
      uvBrightnessEl.value = val; uvBrightnessValEl.textContent = String(val);
      try {
        await writer.write(encoder.encode(`BR:${val}\n`));
        logStatus(`Commando verstuurd: BR:${val}`);
      }
      catch (err) { console.error(err); logStatus('Schrijffout: ' + err.message); }
    }

    /* Reset na UV_OFF */
    function resetPlotAfterUV() {
      baseTimeSec = Date.now()/1000;
      dataPoints = [];
      buffer = '';
      fitHalfLifeActive=false; fitPowerActive=false; manualHalfLifeActive=false;
      halfLifeDataset=null; powerDataset=null; manualHalfLifeDataset=null;
      fitHalfLifeBtn.classList.remove('btn-on'); fitHalfLifeBtn.textContent='Halfwaardetijd-fit';
      fitPowerBtn.classList.remove('btn-on');    fitPowerBtn.textContent ='Machtswet-fit';
      toggleManualHalfLifeBtn.classList.remove('manual-on');
      halfLifeResultEl.textContent=''; fitResultEl.textContent='';
      chart.options.scales.x.min = 0;
      chart.options.scales.x.max = 60;
      chart.options.scales.y.min = 0;
      delete chart.options.scales.y.max;
      rebuildDatasets();
    }

    /* ======= Fits ======= */
    function linearFitXY(xs, ys) {
      const n = xs.length;
      let sx=0, sy=0, sxx=0, sxy=0;
      for (let i=0;i<n;i++){ const x=xs[i], y=ys[i]; sx+=x; sy+=y; sxx+=x*x; sxy+=x*y; }
      const den = n*sxx - sx*sx;
      if (Math.abs(den) < 1e-12) return null;
      const m = (n*sxy - sx*sy)/den;
      const c = (sy - m*sx)/n;
      return { m, c };
    }

    /* Halfwaardetijd: I(t) = I0 * (1/2)^(t/tHalf) — fit t>=1 s; I0 uit intercept */
    function fitHalfLifeParams(points) {
      const valid = points.filter(p => p.x >= 1.0 && p.y > 0);
      if (valid.length < 3) return { ok:false, msg:'Te weinig punten na t ≥ 1 s.' };

      const t = valid.map(p => p.x);
      const lnI = valid.map(p => Math.log(p.y));
      const lf = linearFitXY(t, lnI);
      if (!lf) return { ok:false, msg:'Lineaire fit mislukt.' };
      if (lf.m >= 0) return { ok:false, msg:'Geen verval (helling ≥ 0).' };

      const tHalf = Math.log(2) / (-lf.m);   // m = -ln2 / tHalf
      const I0 = Math.exp(lf.c);             // I0 = exp(c) bij t=0

      // R^2 in origineel domein
      const ys = valid.map(p => p.y);
      const meanY = ys.reduce((s,v)=>s+v,0)/ys.length;
      let sse=0, sst=0;
      for (let i=0;i<valid.length;i++) {
        const pred = I0 * Math.pow(0.5, valid[i].x / tHalf);
        const e = ys[i] - pred; sse += e*e;
        const d = ys[i] - meanY; sst += d*d;
      }
      const r2 = (sst>0) ? (1 - sse/sst) : 1;
      return { ok:true, I0, tHalf, r2 };
    }

    // Halfwaardecurve: ALTIJD vanaf t=0
    function buildHalfLifeDataset(I0, tHalf, tMax, step=0.05) {
      const data = [];
      for (let t = 0; t <= tMax + 1e-9; t += step) {
        const y = I0 * Math.pow(0.5, t / tHalf);
        if (isFinite(y)) data.push({ x:t, y });
      }
      return { label:'Fit (halfwaardetijd)', data, borderColor:'#7b2cbf', borderWidth:2, pointRadius:0, showLine:true };
    }

    /* Machtwet: I = a/(t+t0)^b */
    function fitPowerLaw(points, bMin=0.2, bMax=2.0) {
      const valid = points.filter(p => p.y > 0);
      if (valid.length < 3) return { ok:false, msg:'Te weinig positieve punten voor log-fit.' };
      const tArr = valid.map(p=>p.x), iArr = valid.map(p=>p.y);
      const maxT = Math.max(...tArr);
      const t0Max = Math.max(5, 0.5*maxT);
      const N=80;

      function sseR2(a,b,t0, T,I){
        const n=I.length, mean=I.reduce((s,v)=>s+v,0)/n;
        let sse=0,sst=0;
        for (let i=0;i<n;i++){
          const pred = a / Math.pow(T[i]+t0, b);
          const e=I[i]-pred; sse+=e*e;
          const d=I[i]-mean; sst+=d*d;
        }
        return {sse, r2:(sst>0)?(1-sse/sst):1};
      }

      let best = { sse:Infinity, a:NaN, b:NaN, t0:NaN, r2:NaN };
      for (let k=0;k<N;k++){
        const t0=(k/(N-1))*t0Max;
        const xs=[], ys=[], T=[], I=[];
        for (let i=0;i<valid.length;i++){
          const u=tArr[i]+t0, Ival=iArr[i];
          if (u>0 && Ival>0){ xs.push(Math.log(u)); ys.push(Math.log(Ival)); T.push(tArr[i]); I.push(Ival); }
        }
        if (xs.length<3) continue;
        const lf=linearFitXY(xs,ys); if(!lf) continue;
        let b=-lf.m; let a=Math.exp(lf.c);
        if (b<bMin || b>bMax) continue;
        const {sse,r2}=sseR2(a,b,t0,T,I);
        if (sse<best.sse) best={sse,a,b,t0,r2};
      }
      if (!isFinite(best.sse)) {
        // fallback met b-clamp
        for (let k=0;k<N;k++){
          const t0=(k/(N-1))*t0Max;
          const xs=[], ys=[], T=[], I=[];
          for (let i=0;i<valid.length;i++){
            const u=tArr[i]+t0, Ival=iArr[i];
            if (u>0 && Ival>0){ xs.push(Math.log(u)); ys.push(Math.log(Ival)); T.push(tArr[i]); I.push(Ival); }
          }
          if (xs.length<3) continue;
          const lf=linearFitXY(xs,ys); if(!lf) continue;
          let b=Math.min(bMax, Math.max(bMin, -lf.m));
          const a=Math.exp(lf.c);
          const {sse,r2}=sseR2(a,b,t0,T,I);
          if (sse<best.sse) best={sse,a,b,t0,r2};
        }
        if (!isFinite(best.sse)) return { ok:false, msg:'Geen geschikte t₀ gevonden.' };
      }
      return { ok:true, ...best, n: valid.length };
    }

    function buildPowerDataset(a,b,t0,tMin,tMax,step=0.05){
      const data=[];
      for (let t=tMin; t<=tMax+1e-9; t+=step) {
        const y = a / Math.pow(t + t0, b);
        if (isFinite(y)) data.push({x:t,y});
      }
      return { label:'Fit (machtwet)', data, borderColor:'#e03a3a', borderWidth:2, pointRadius:0, showLine:true };
    }

    /* ======= Toggle knoppen ======= */
    fitHalfLifeBtn.addEventListener('click', () => {
      if (fitHalfLifeActive) {
        // UIT
        fitHalfLifeActive=false; halfLifeDataset=null;
        halfLifeResultEl.textContent=''; fitHalfLifeBtn.classList.remove('btn-on');
        fitHalfLifeBtn.textContent='Halfwaardetijd-fit';
        rebuildDatasets();
        return;
      }
      // AAN
      if (keepReading) { alert("Stop eerst de meting."); return; }
      if (dataPoints.length < 3) { alert("Te weinig data."); return; }
      const res = fitHalfLifeParams(dataPoints);
      if (!res.ok) { halfLifeResultEl.textContent='Fit mislukt: '+res.msg; return; }
      const allT = dataPoints.map(p=>p.x);
      const tMin = Math.max(0, Math.min(...allT));
      const tMax = Math.max(...allT);

      // Curve altijd vanaf 0
      halfLifeDataset = buildHalfLifeDataset(res.I0, res.tHalf, tMax);

      // assen
      const allY=[...dataPoints.map(p=>p.y), ...halfLifeDataset.data.map(p=>p.y)].filter(Number.isFinite);
      if (allY.length){ const maxY=Math.max(...allY); chart.options.scales.y.min=0; chart.options.scales.y.max=maxY*1.1; }
      chart.options.scales.x.min = Math.floor(tMin);
      chart.options.scales.x.max = Math.ceil(tMax);

      halfLifeResultEl.textContent = `I₀=${res.I0.toExponential(3)}, t½=${res.tHalf.toFixed(3)} s, R²=${res.r2.toFixed(4)}`;
      fitHalfLifeActive=true; fitHalfLifeBtn.classList.add('btn-on');
      fitHalfLifeBtn.textContent='Verberg halfwaardetijd fit';

      // (optioneel) sliders initialiseren op fitwaarden:
      manualI0Range.value = manualI0Num.value = (+res.I0.toFixed(2)).toString();
      manualTHRange.value = manualTHNum.value = (+res.tHalf.toFixed(2)).toString();

      rebuildDatasets();
    });

    fitPowerBtn.addEventListener('click', () => {
      if (fitPowerActive) {
        // UIT
        fitPowerActive=false; powerDataset=null;
        fitResultEl.textContent=''; fitPowerBtn.classList.remove('btn-on');
        fitPowerBtn.textContent='Machtswet-fit';
        rebuildDatasets();
        return;
      }
      // AAN
      if (keepReading) { alert("Stop eerst de meting."); return; }
      if (dataPoints.length < 3) { alert("Te weinig data om te fitten."); return; }
      const fit = fitPowerLaw(dataPoints, 0.2, 2.0);
      if (!fit.ok) { fitResultEl.textContent='Fit mislukt: '+fit.msg; return; }
      const tMin = Math.max(0, Math.min(...dataPoints.map(p=>p.x)));
      const tMax = Math.max(...dataPoints.map(p=>p.x));
      powerDataset = buildPowerDataset(fit.a, fit.b, fit.t0, tMin, tMax);
      const allY=[...dataPoints.map(p=>p.y), ...powerDataset.data.map(p=>p.y)].filter(Number.isFinite);
      if (allY.length){ const maxY=Math.max(...allY); chart.options.scales.y.min=0; chart.options.scales.y.max=maxY+Math.max(0.01,maxY*0.1); }
      chart.options.scales.x.min = Math.floor(tMin);
      chart.options.scales.x.max = Math.ceil(tMax);
      fitResultEl.textContent = `a=${fit.a.toExponential(3)}, b=${fit.b.toFixed(3)}, t₀=${fit.t0.toFixed(3)} s, R²=${fit.r2.toFixed(4)}`;
      fitPowerActive=true; fitPowerBtn.classList.add('btn-on');
      fitPowerBtn.textContent='Verberg machtswet fit';
      rebuildDatasets();
    });

    /* ======= Handmatige halfwaardecurve ======= */
    function getManualParams() {
      const I0   = parseFloat(manualI0Range.value);
      const tHalf= parseFloat(manualTHRange.value);
      return { I0, tHalf };
    }

    function syncManualInputs(src) {
      if (src === 'I0-range')   manualI0Num.value = manualI0Range.value;
      if (src === 'I0-num')     manualI0Range.value = manualI0Num.value;
      if (src === 'TH-range')   manualTHNum.value = manualTHRange.value;
      if (src === 'TH-num')     manualTHRange.value = manualTHNum.value;
    }

    function buildManualHalfLifeDataset(I0, tHalf, tMax, step = 0.05) {
      const data = [];
      for (let t = 0; t <= tMax + 1e-9; t += step) {
        const y = I0 * Math.pow(0.5, t / tHalf);
        if (isFinite(y)) data.push({ x: t, y });
      }
      return {
        label: 'Handmatige halfwaardecurve',
        data,
        borderColor: '#7b2cbf',
        borderWidth: 2,
        pointRadius: 0,
        showLine: true,
        borderDash: [6, 3]
      };
    }

    function updateManualCurve() {
      if (!manualHalfLifeActive) return;
      const { I0, tHalf } = getManualParams();

      const tMax = isFinite(chart.options.scales.x.max)
        ? chart.options.scales.x.max
        : (dataPoints.length ? Math.max(...dataPoints.map(p=>p.x)) : 10);

      manualHalfLifeDataset = buildManualHalfLifeDataset(I0, tHalf, Math.max(1, tMax));

      // y-as bijstellen op basis van data + curve
      const allY = [
        ...dataPoints.map(p => p.y),
        ...manualHalfLifeDataset.data.map(p => p.y)
      ].filter(Number.isFinite);

      if (allY.length) {
        const maxY = Math.max(...allY);
        chart.options.scales.y.min = 0;
        chart.options.scales.y.max = maxY + Math.max(0.01, maxY * 0.1);
      }

      rebuildDatasets();
    }

    toggleManualHalfLifeBtn.addEventListener('click', () => {
      manualHalfLifeActive = !manualHalfLifeActive;
      if (manualHalfLifeActive) {
        toggleManualHalfLifeBtn.classList.add('manual-on');
        updateManualCurve(); // initial build
      } else {
        toggleManualHalfLifeBtn.classList.remove('manual-on');
        manualHalfLifeDataset = null;
        rebuildDatasets();
      }
    });

    // Sliders & number inputs synchroon + live update
    manualI0Range.addEventListener('input', () => { syncManualInputs('I0-range'); updateManualCurve(); });
    manualI0Num  .addEventListener('input', () => { syncManualInputs('I0-num');   updateManualCurve(); });
    manualTHRange.addEventListener('input', () => { syncManualInputs('TH-range'); updateManualCurve(); });
    manualTHNum  .addEventListener('input', () => { syncManualInputs('TH-num');   updateManualCurve(); });
  </script>
</body>
</html>